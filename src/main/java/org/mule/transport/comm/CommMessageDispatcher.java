/*
 * Generated by the Mule project wizard. http://mule.mulesource.org
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */
package org.mule.transport.comm;

import org.mule.transport.AbstractMessageDispatcher;
import org.mule.api.endpoint.OutboundEndpoint;
import org.mule.api.endpoint.ImmutableEndpoint;
import org.mule.api.MuleEvent;
import org.mule.api.MuleMessage;
import org.mule.api.transformer.TransformerException;
import org.mule.DefaultMuleMessage;

import javax.comm.CommPort;
import javax.comm.PortInUseException;
import java.io.*;

/**
 * Created by IntelliJ IDEA.
 * User: Christopher Cheng
 * Date: Mar 1, 2009
 * Time: 2:57:04 PM
 * To change this template use File | Settings | File Templates.
 */
public class CommMessageDispatcher extends AbstractMessageDispatcher
{

    private final CommConnector connector;

    public CommMessageDispatcher(OutboundEndpoint endpoint)
    {
        super(endpoint);
        this.connector = (CommConnector) endpoint.getConnector();
    }

    protected synchronized void doDispatch(MuleEvent event) throws Exception
    {
        CommPort commPort = connector.getPort(event.getEndpoint());
        try
        {

            dispatchToSocket(commPort, event);
        }
        finally
        {
            connector.releasePort(commPort, event.getEndpoint());
        }
    }

    protected synchronized MuleMessage doSend(MuleEvent event) throws Exception
    {
        CommPort port = connector.getPort(event.getEndpoint());

        // todo: this code is ok
//        String msg = (char) 2 + "VEHICLESENSOR_CHANNEL1_REPORT_STATE" + (char) 3;
//        port.getOutputStream().write(msg.getBytes());
//        readData(port.getInputStream());

//        event.getMessage().setPayload(msg.getBytes());

//        return null;
        dispatchToSocket(port, event);

        try
        {

            if (useRemoteSync(event))
            {
//                System.out.println("useRemoteSync=true");
                try
                {
                    Object result = receiveFromPort(port, event.getTimeout(), endpoint);
//                    System.out.println("received result " + result);
                    if (result == null)
                    {
                        return null;
                    }

                    if (result instanceof MuleMessage)
                    {
                        return (MuleMessage) result;
                    }

                    return new DefaultMuleMessage(connector.getMessageAdapter(result));
                }
                catch (Exception e)
                {
                    e.printStackTrace(System.out);
                    // we don't necessarily expect to receive a response here
                    logger.info("Port timed out normally while doing a synchronous receive on endpointUri: "
                        + event.getEndpoint().getEndpointURI());
                    return null;
                }
            }
            else
            {
//                System.out.println("useRemoteSync=false");
                return event.getMessage();
            }
        }
        finally
        {
            if (!useRemoteSync(event))
            {
//                System.out.print("releasing port");

                connector.releasePort(port, endpoint);
            }
        }

    }

    // Socket management (get and release) is handled outside this method
    private void dispatchToSocket(CommPort port, MuleEvent event) throws Exception
    {
        Object payload = event.transformMessage();
        write(port, payload);
    }

    private void write(CommPort port, Object data) throws IOException, TransformerException
    {
        BufferedOutputStream bos = new BufferedOutputStream(port.getOutputStream());
        connector.getCommProtocol().write(bos, data);
        bos.flush();
    }

    private void readData(InputStream theInput) throws IOException {

        String s = "";

        System.out.println("readData");

        while (true) {

                // Read buffer until Char(3) is received
                int i = 0;
                byte b = 0;
                boolean start = false;
                while (b != -1) {
                    int n = theInput.read();
                    b = (byte) n;
                    System.out.println("read=" + (char) b);
                    if (n != -1) {
//                        System.out.println("read:" + n + ",<" + (char) n + ">");
                    }
                    if (b == 2) {
                        s = "";
                    }
                    if (b != -1 && b != 2 && b != 3) {
    //                        buffer[i++] = b;
                        s += (char) b;
                    }
                }

                // Pad the Buffer with space
    //                for (int j = i; j < Globals.MESSAGE_LENGTH; j++) {
    //                    buffer[j] = (byte) ' ';
    //                }

                // Closes the port before we go
    //                if (state == 0) {
    //                    DeviceManager.closePort(port);
    //                    break;
    //                }

                // Transform the buffer to a String
    //                String code = new String(buffer);

                // Clear the whole buffer
    //                buffer = new byte[Globals.MESSAGE_LENGTH * 2];

                // Tell Processor to process the code
    //                if (processor != null)
    //                    processor.process(s);
    //                else
    //                    System.out.println(s);
                System.out.println("s=" + s);

            }
    }

    protected static Object receiveFromPort(final CommPort port, int timeout, final ImmutableEndpoint endpoint)
            throws IOException
    {
        final CommConnector connector = (CommConnector) endpoint.getConnector();
        DataInputStream underlyingIs = new DataInputStream(new BufferedInputStream(port.getInputStream()));
        CommInputStream tis = new CommInputStream(underlyingIs)
        {
            public void close() throws IOException
            {
                try
                {
                    connector.releasePort(port, endpoint);
                }
                catch (IOException e)
                {
                   throw e;
                }
                catch (Exception e)
                {
                    IOException e2 = new IOException();
                    e2.initCause(e);
                    throw e2;
                }
            }

        };

        // todo check if there's a comm port timeout
//        if (timeout >= 0)
//        {
//            port.setSoTimeout(timeout);
//        }

        try
        {
            return connector.getCommProtocol().read(tis);
        }
        finally
        {
            if (!tis.isStreaming())
            {
                tis.close();
            }
        }
    }

    protected synchronized void doDispose()
    {
        try
        {
            doDisconnect();
        }
        catch (Exception e)
        {
            logger.error("Failed to shutdown the dispatcher.", e);
        }
    }

    protected void doConnect() throws Exception
    {
        // Test the connection
        if (connector.isValidateConnections())
        {
            CommPort port = connector.getPort(endpoint);
            connector.releasePort(port, endpoint);
        }
    }

    protected void doDisconnect() throws Exception
    {
        //nothing to do
    }

}